{"version":3,"file":"enigma-mixin.min.js","sources":["../src/mixins/doc/object-definitions.js","../src/mixins/doc/qVariables.js","../src/mixins/doc/qSelections.js","../src/mixins/doc/qTablesAndFields.js","../src/mixins/doc/extension-objects.js","../src/lib/helpers.js","../src/mixins/doc/unbuild.js","../src/mixins/doc/build.js","../src/main.js"],"sourcesContent":["const sessionList = {\r\n    \"qInfo\": {\r\n        \"qId\": \"\",\r\n        \"qType\": \"SessionLists\"\r\n    },\r\n    \"qSelectionObjectDef\": {}\r\n}\r\n\r\nconst variableList = {\r\n    \"qInfo\": {\r\n        \"qType\": \"VariableList\"\r\n    },\r\n    \"qVariableListDef\": {\r\n        \"qType\": \"variable\"\r\n    }\r\n}\r\n\r\nconst listBox = {\r\n    \"qInfo\": {\r\n        \"qId\": \"\",\r\n        \"qType\": \"Combo\"\r\n    },\r\n    \"field\": {\r\n        \"qListObjectDef\": {\r\n            \"qStateName\": \"$\",\r\n            \"qDef\": {\r\n                \"qFieldDefs\": [],\r\n                \"qSortCriterias\": [{\r\n                    \"qSortByState\": 1,\r\n                    \"qExpression\": {}\r\n                }]\r\n            },\r\n            \"qInitialDataFetch\": [{\r\n                \"qTop\": 0,\r\n                \"qLeft\": 0,\r\n                \"qHeight\": 100,\r\n                \"qWidth\": 1\r\n            }]\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    sessionList,\r\n    variableList,\r\n    listBox\r\n}","const objectDefinitions = require('./object-definitions.js');\r\n\r\nasync function mGetVariablesAll({ showSession = false, showConfig = false, showReserved = false } = {}) {\r\n    let objProp = objectDefinitions.variableList\r\n    objProp.qShowSession = showSession\r\n    objProp.qShowConfig = showConfig\r\n    objProp.qShowReserved = showReserved\r\n\r\n    try {\r\n        let sessionObj = await this.createSessionObject(objProp)\r\n        let sessionObjLayout = await sessionObj.getLayout()\r\n        return sessionObjLayout.qVariableList.qItems\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\nasync function mUpdateVariable(variable) {\r\n    try {\r\n        let variableContent = await this.getVariableById(variable.qInfo.qId)\r\n        let newContent = await variableContent.setProperties(variable)\r\n\r\n        return newContent\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\nasync function mCreateVariable({ name, comment = '', definition }) {\r\n\r\n    let varProps = {\r\n        \"qInfo\": {\r\n            \"qType\": \"variable\"\r\n        },\r\n        \"qName\": name,\r\n        \"qComment\": comment,\r\n        \"qDefinition\": definition\r\n    }\r\n\r\n    try {\r\n        let result = await this.createVariableEx(varProps)\r\n        return result\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    mGetVariablesAll,\r\n    mUpdateVariable,\r\n    mCreateVariable\r\n}\r\n","const objectDefinitions = require('./object-definitions.js')\r\n\r\nasync function iGetSelectionsNative(qDoc) {\r\n    try {\r\n        let sessionObj = await qDoc.createSessionObject(objectDefinitions.sessionList)\r\n        let selections = await sessionObj.getLayout()\r\n        return selections\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n\r\n}\r\n\r\nasync function mGetSelectionsCurrNative() {\r\n    try {\r\n        let selections = await iGetSelectionsNative(this)\r\n        return selections\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\n/**\r\n * Get current selections\r\n */\r\nasync function mGetSelectionsCurr() {\r\n    try {\r\n        let selections = await iGetSelectionsNative(this)\r\n\r\n        let fieldsSelected = selections.qSelectionObject.qSelections.map(function (s) {\r\n            return s.qField\r\n        })\r\n\r\n        return { selections: selections.qSelectionObject.qSelections, fields: fieldsSelected }\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\n/**\r\n * Select value(s) in a field\r\n * @param {string} fieldName - Name of the field\r\n * @param {array} values - String array with the values to be selected\r\n * @param {boolean} [toggle=false] toggle - How to apply the selection\r\n */\r\nasync function mSelectInField({ fieldName, values, toggle = false }) {\r\n\r\n    try {\r\n        let field = await this.getField(fieldName)\r\n\r\n        let valuesToSelect = values.map(function (v) {\r\n            return {\r\n                qText: v\r\n            }\r\n        })\r\n\r\n        try {\r\n            let selection = await field.selectValues({ qFieldValues: valuesToSelect, qToggleMode: toggle })\r\n            return selection\r\n        } catch (e) {\r\n            throw new Error(e.message)\r\n        }\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    mGetSelectionsCurr,\r\n    mGetSelectionsCurrNative,\r\n    mSelectInField\r\n}\r\n","const objectDefinitions = require('./object-definitions.js')\r\n\r\nasync function mGetTablesAndFields() {\r\n\r\n    try {\r\n        let tables = await this.getTablesAndKeys({}, {}, 0, true, false)\r\n\r\n        let f = [];\r\n\r\n        if (tables.qtr.length == 0) {\r\n            return f\r\n        } else {\r\n            for (let table of tables.qtr) {\r\n                for (let field of table.qFields) {\r\n                    f.push({ table: table.qName, field: field.qName })\r\n                }\r\n            }\r\n\r\n            return f\r\n        }\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\nasync function mGetTables() {\r\n    try {\r\n        let qTables = await this.getTablesAndKeys({}, {}, 0, true, false)\r\n\r\n        let tables = [];\r\n\r\n        if (qTables.length == 0) {\r\n            return tables\r\n        } else {\r\n            for (let table of qTables.qtr) {\r\n                tables.push(table.qName)\r\n            }\r\n\r\n            return tables\r\n        }\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\nasync function mGetFields() {\r\n    try {\r\n\r\n        let qTables = await this.getTablesAndKeys({}, {}, 0, true, false)\r\n\r\n        let fields = [];\r\n\r\n        for (let table of qTables.qtr) {\r\n            for (let field of table.qFields) {\r\n                fields.push(field.qName)\r\n            }\r\n        }\r\n\r\n        return fields\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n}\r\n\r\nasync function mGetListbox(fieldName) {\r\n\r\n    try {\r\n        let lbDef = objectDefinitions.listBox\r\n        lbDef.field.qListObjectDef.qDef.qFieldDefs.push(fieldName)\r\n        let sessionObj = await this.createSessionObject(lbDef)\r\n        let fieldValues = await sessionObj.getLayout()\r\n        return fieldValues.field.qListObject\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = {\r\n    mGetTablesAndFields,\r\n    mGetTables,\r\n    mGetFields,\r\n    mGetListbox\r\n} ","const nonExtensionObjects = [\r\n    \"barchart\",\r\n    \"bookmark\",\r\n    \"combochart\",\r\n    \"dimension\",\r\n    \"embeddedsnapshot\",\r\n    \"filterpane\",\r\n    \"gauge\",\r\n    \"kpi\",\r\n    \"linechart\",\r\n    \"listbox\",\r\n    \"LoadModel\",\r\n    \"map\",\r\n    \"masterobject\",\r\n    \"measure\",\r\n    \"piechart\",\r\n    \"pivot-table\",\r\n    \"scatterplot\",\r\n    \"sheet\",\r\n    \"slide\",\r\n    \"slideitem\",\r\n    \"snapshot\",\r\n    \"story\",\r\n    \"StringExpression\",\r\n    \"table\",\r\n    \"treemap\"\r\n]\r\n\r\nasync function mGetAllExtensionObjects() {\r\n    let allInfos = await this.getAllInfos()\r\n    let extensionObjects = await filterOnlyExtensionObjects(this, allInfos)\r\n\r\n    return extensionObjects\r\n}\r\n\r\n\r\n\r\nasync function filterOnlyExtensionObjects(qDoc, allObjects) {\r\n    let possibleExtensionObjects = allObjects.filter(function (o) {\r\n        return nonExtensionObjects.indexOf(o.qType) == -1\r\n    })\r\n\r\n    let realExtensionObjects = []\r\n    if (possibleExtensionObjects.length > 0) {\r\n        for (let extObj of possibleExtensionObjects) {\r\n            let isReallyExtension = await realExtensionCheck(qDoc, extObj.qId)\r\n            if (isReallyExtension.isExtension) {\r\n                realExtensionObjects.push({\r\n                    appName: qDoc.id,\r\n                    objId: isReallyExtension.qObjProps.qInfo.qId,\r\n                    objType: isReallyExtension.qObjProps.qInfo.qType,\r\n                    extName: isReallyExtension.qObjProps.extensionMeta.name,\r\n                    extVersion: isReallyExtension.qObjProps.version,\r\n                    extVisible: isReallyExtension.qObjProps.extensionMeta.visible,\r\n                    extIsBundle: !isReallyExtension.qObjProps.extensionMeta.isThirdParty,\r\n                    extIsLibrary: isReallyExtension.qObjProps.extensionMeta.isLibraryItem,\r\n                    qProps: isReallyExtension.qObjProps\r\n                })\r\n            }\r\n        }\r\n\r\n        return realExtensionObjects\r\n    } else {\r\n        return []\r\n    }\r\n}\r\n\r\nconst realExtensionCheck = async function (qDoc, objId) {\r\n    let isExtension = false\r\n    let qObjProps = {}\r\n\r\n    try {\r\n        let qObj = await qDoc.getObject(objId)\r\n\r\n        qObjProps = await qObj.getProperties()\r\n\r\n        if (qObjProps.extensionMeta) {\r\n            isExtension = true\r\n        }\r\n\r\n    } catch (e) {\r\n        throw new Error(e.message)\r\n    }\r\n    return { qObjProps, isExtension }\r\n}\r\n\r\nmodule.exports = {\r\n    mGetAllExtensionObjects\r\n}","const handlePromise = (promise) => {\r\n    return promise\r\n        .then(data => ([data, undefined]))\r\n        .catch(error => Promise.resolve([undefined, error]));\r\n}\r\n\r\nmodule.exports = {\r\n    handlePromise\r\n}","const objectDefinitions = require('./object-definitions.js');\r\nconst { handlePromise } = require('../../lib/helpers');\r\n\r\nasync function mUnbuild() {\r\n    return await Promise.all([\r\n        await unbuildVariables(this),\r\n        await unbuildScript(this),\r\n        await unbuildAppProperties(this),\r\n        await unbuildConnections(this),\r\n        await unbuildEntities(this)\r\n    ]).then((data) => ({\r\n        variables: data[0],\r\n        script: data[1],\r\n        appProperties: data[2],\r\n        connections: data[3],\r\n        dimensions: data[4].dimensions,\r\n        measures: data[4].measures,\r\n        objects: data[4].objects\r\n    }))\r\n}\r\n\r\nasync function unbuildVariables(app) {\r\n    let objProp = objectDefinitions.variableList\r\n    objProp.qShowSession = false\r\n    objProp.qShowConfig = false\r\n    objProp.qShowReserved = false\r\n\r\n    let [sessionObj, sessionObjErr] = await handlePromise(app.createSessionObject(objProp))\r\n    if (sessionObjErr) throw new Error('unbuild variables: cannot create session object');\r\n\r\n    let [sessionObjLayout, sessionObjLayoutErr] = await handlePromise(sessionObj.getLayout())\r\n    if (sessionObjLayoutErr) throw new Error('unbuild variables: cannot get session object layout');\r\n\r\n    let [delSessionObj, delSessionObjErr] = await handlePromise(app.destroySessionObject(sessionObj.id))\r\n    if (delSessionObjErr) throw new Error('unbuild variables: cannot delete session object');\r\n\r\n    return sessionObjLayout.qVariableList.qItems\r\n}\r\n\r\nasync function unbuildScript(app) {\r\n    let [script, scriptErr] = await handlePromise(app.getScript())\r\n    if (scriptErr) throw new Error('unbuild script: cannot fetch script');\r\n\r\n    return script\r\n}\r\n\r\nasync function unbuildAppProperties(app) {\r\n    let [appProperties, appPropertiesError] = await handlePromise(app.getAppProperties())\r\n    if (appPropertiesError) throw new Error('unbuild app properties: cannot fetch app properties');\r\n\r\n    return appProperties\r\n\r\n}\r\n\r\nasync function unbuildConnections(app) {\r\n    let [appConnections, appConnectionsErr] = await handlePromise(app.getConnections())\r\n    if (appConnectionsErr) throw new Error('unbuild connections: cannot fetch app connections');\r\n\r\n    return appConnections\r\n}\r\n\r\nasync function unbuildEntities(app) {\r\n    let data = {\r\n        dimensions: [],\r\n        measures: [],\r\n        objects: []\r\n    }\r\n\r\n    let errors = []\r\n\r\n    // get list of all objects\r\n    let [appAllInfos, appAllInfosErr] = await handlePromise(app.getAllInfos())\r\n    if (appAllInfosErr) throw new Error('unbuild app infos: cannot fetch all app infos')\r\n\r\n    return Promise.all(appAllInfos.map(async function (item) {\r\n        if (item.qType == 'dimension') {\r\n            let [dim, dimErr] = await handlePromise(app.getDimension(item.qId))\r\n            if (dimErr) throw new Error('unbuild dimension: cannot fetch dimension')\r\n\r\n            let [dimProp, dimPropErr] = await handlePromise(dim.getProperties())\r\n            if (dimPropErr) throw new Error('unbuild dimension: cannot fetch dimension properties')\r\n\r\n            data.dimensions.push(dimProp)\r\n        }\r\n\r\n        if (item.qType == 'measure') {\r\n            let [measure, measureErr] = await handlePromise(app.getMeasure(item.qId))\r\n            if (measureErr) throw new Error('unbuild dimension: cannot fetch measure')\r\n\r\n            let [measureProp, measurePropErr] = await handlePromise(measure.getProperties())\r\n            if (measurePropErr) throw new Error('unbuild dimension: cannot fetch measure properties')\r\n\r\n            data.measures.push(measureProp)\r\n        }\r\n\r\n        if (item.qType != 'dimension' && item.qType != 'measure') {\r\n            let o = await processObject(item, app)\r\n\r\n            if (!o.error) data.objects.push(o)\r\n            if (o.error) errors.push(o)\r\n        }\r\n    })).then(() => data)\r\n}\r\n\r\nasync function processObject(item, app) {\r\n    let [obj, objErr] = await handlePromise(app.getObject(item.qId))\r\n\r\n    // embeddedsnapshot, snapshot, hiddenbookmark, story --> need to be handled differently\r\n    if (objErr) return { ...item, error: true }\r\n\r\n    let [parent, parentErr] = await handlePromise(obj.getParent())\r\n    let [children, childrenErr] = await obj.getChildInfos()\r\n\r\n    if (childrenErr) throw new Error('unbuild entity: cannot fetch entity children')\r\n\r\n    // parent-less objects - masterobject, sheet, appprops, LoadModel\r\n    if (parentErr && children.length > 0) {\r\n        let [propTree, propTreeErr] = await handlePromise(obj.getFullPropertyTree())\r\n        if (propTreeErr) throw new Error('unbuild entity: cannot fetch entity full property tree')\r\n\r\n        return propTree\r\n    }\r\n\r\n    let [prop, propErr] = await handlePromise(obj.getProperties())\r\n    if (propErr) throw new Error('unbuild entity: cannot fetch entity properties')\r\n\r\n    return prop\r\n}\r\n\r\nmodule.exports = {\r\n    mUnbuild\r\n}","const { handlePromise } = require('../../lib/helpers');\r\n\r\nasync function mBuild({\r\n    variables = [],\r\n    script = false,\r\n    appProperties = {},\r\n    connections = [],\r\n    measures = [],\r\n    dimensions = [],\r\n    objects = [] }) {\r\n\r\n    let [appConnections, error] = await handlePromise(this.getConnections())\r\n    if (error) throw new Error('build: cannot get app connections')\r\n\r\n    return Promise.all([\r\n        await processMeasures(measures, this),\r\n        await processDimensions(dimensions, this),\r\n        await processVariables(variables, this),\r\n        await processScript(script, this),\r\n        await processAppProperties(appProperties, this),\r\n        await processConnections(appConnections, connections, this),\r\n        await processObjects(objects, this)\r\n    ]).then(function (d) {\r\n        return {\r\n            measures: d[0],\r\n            dimensions: d[1],\r\n            variables: d[2],\r\n            script: d[3],\r\n            appProperties: d[4],\r\n            connections: d[5],\r\n            objects: d[6]\r\n        }\r\n    })\r\n}\r\n\r\n\r\nasync function processMeasures(measures, app) {\r\n    return Promise.all(measures.map(async function (measure) {\r\n        let [obj, objErr] = await handlePromise(app.getMeasure(measure.qInfo.qId))\r\n\r\n        // the measure do not exists and need to be created\r\n        if (objErr) {\r\n            let [created, error] = await handlePromise(app.createMeasure(measure))\r\n            if (error) throw new Error(`build measure: cannot create measure \"${measure.qInfo.qId}\": ${error.message}`)\r\n\r\n            return { qId: measure.qInfo.qId, status: 'Created' }\r\n        }\r\n\r\n        // the measure exists and need to be updated\r\n        let [updated, error] = await handlePromise(obj.setProperties(measure))\r\n        if (error) throw new Error(`build measure: cannot update measure \"${measure.qInfo.qId}\": ${error.message}`)\r\n\r\n        return { qId: measure.qInfo.qId, status: 'Updated' }\r\n    }))\r\n}\r\n\r\nasync function processDimensions(dimensions, app) {\r\n    return Promise.all(dimensions.map(async function (dimension) {\r\n        let [obj, objErr] = await handlePromise(app.getDimension(dimension.qInfo.qId))\r\n\r\n        // the dimension do not exists and need to be created\r\n        if (objErr) {\r\n            let [created, error] = await handlePromise(app.createDimension(dimension))\r\n            if (error) throw new Error(`build dimension: cannot create dimension \"${dimension.qInfo.qId}\": ${error.message}`)\r\n\r\n            return { qId: dimension.qInfo.qId, status: 'Created' }\r\n        }\r\n\r\n        // the dimension exists and need to be updated\r\n        let [updated, error] = await handlePromise(obj.setProperties(measure))\r\n        if (error) throw new Error(`build dimension: cannot update dimension \"${dimension.qInfo.qId}\": ${error.message}`)\r\n\r\n        return { qId: dimension.qInfo.qId, status: 'Updated' }\r\n    }))\r\n}\r\n\r\nasync function processScript(script, app) {\r\n    let [s, error] = await handlePromise(app.setScript(script))\r\n    if (error) throw new Error(`build script: cannot set script: ${error.message}`)\r\n\r\n    return { status: 'Set' }\r\n}\r\n\r\nasync function processAppProperties(appProperties, app) {\r\n    let [update, error] = await handlePromise(app.setAppProperties(appProperties))\r\n    if (error) throw new Error(`build app properties: cannot set app properties: ${error.message}`)\r\n\r\n    return { status: 'Set' }\r\n}\r\n\r\nasync function processVariables(variables, app) {\r\n    return Promise.all(variables.map(async function (variable) {\r\n        let [qVar, qVarError] = await handlePromise(app.getVariableByName(variable.qName))\r\n\r\n        if (qVarError) {\r\n            let [created, error] = await handlePromise(app.createVariableEx(variable))\r\n            if (error) throw new Error(`build variable: cannot create variable \"${variable.qName}\": ${error.message}`)\r\n\r\n            return { qId: variable.qName, status: 'Created' }\r\n        }\r\n\r\n        let [updated, error] = await handlePromise(qVar.setProperties(variable))\r\n        if (error) throw new Error(`build variable: cannot update variable \"${variable.qName}\": ${error.message}`)\r\n\r\n        return { qId: variable.qName, status: 'Updated' }\r\n    }))\r\n}\r\n\r\nasync function processConnections(appConnections, connections, app) {\r\n    return Promise.all(connections.map(async function (connection) {\r\n        let conn = appConnections.find(o => o.qName === connection.qName)\r\n\r\n        if (!conn) {\r\n            let [create, error] = await handlePromise(app.createConnection(connection))\r\n            if (error) throw new Error(`build connection: cannot create connection \"${connection.qName}\": ${error.message}`)\r\n\r\n            return { qId: connection.qName, status: 'Created' }\r\n        }\r\n\r\n        let [modify, error] = await handlePromise(app.modifyConnection(conn.qId, connection, true))\r\n        if (error) throw new Error(`build connection: cannot modify connection \"${connection.qName}\": ${error.message}`)\r\n\r\n        return { qId: connection.qName, status: 'Updated' }\r\n\r\n    }))\r\n}\r\n\r\nasync function processObjects(objects, app) {\r\n    return Promise.all(objects.map(async function (object) {\r\n        let objId, objType\r\n        let isGenericObject = false;\r\n\r\n        //if the object is GenericObject - the id and the type are in a slightly different path\r\n        if (!object.qInfo) {\r\n            isGenericObject = true\r\n            objId = object.qProperty.qInfo.qId\r\n            objType = object.qProperty.qInfo.qType\r\n        } else {\r\n            objId = object.qInfo.qId\r\n            objType = object.qInfo.qType\r\n        }\r\n\r\n\r\n        let [obj, objError] = await handlePromise(app.getObject(objId))\r\n\r\n        if (!objError) {\r\n            // if its GenericObject we have to set the the props using setFullPropertyTree\r\n            if (isGenericObject) {\r\n                let [updated, error] = await handlePromise(obj.setFullPropertyTree(object))\r\n                if (error) throw new Error(`build object: cannot update object \"${objId}\": ${error.message}`)\r\n\r\n                return { qId: objId, status: 'Updated' }\r\n            }\r\n\r\n            // if not GenericObject then use the \"usual\" setProperties\r\n            if (!isGenericObject) {\r\n                let [updated, error] = await handlePromise(obj.setProperties(object))\r\n                if (error) throw new Error(`build object: cannot update object \"${objId}\": ${error.message}`)\r\n\r\n                return { qId: objId, status: 'Updated' }\r\n            }\r\n        }\r\n\r\n        // same rules are applied when we have to create the object\r\n        if (objError) {\r\n            if (isGenericObject) {\r\n\r\n                let [o, oError] = await handlePromise(app.createObject({\r\n                    qInfo: {\r\n                        qId: `${objId}`,\r\n                        qType: objType\r\n                    }\r\n                }))\r\n                if (oError) throw new Error(`build object: cannot create object \"${objId}\": ${oError.message}`)\r\n\r\n                let [updated, updatedError] = await handlePromise(o.setFullPropertyTree(object))\r\n                if (updatedError) throw new Error(`build object: cannot update object \"${objId}\": ${updatedError.message}`)\r\n\r\n                return { qId: objId, status: 'Created' }\r\n            }\r\n\r\n            if (!isGenericObject) {\r\n                let [created, createdError] = await handlePromise(app.createObject(object))\r\n                if (createdError) throw new Error(`build object: cannot create object: \"${objId}\": ${createdError.message}`)\r\n\r\n                return { qId: objId, status: 'Created' }\r\n            }\r\n        }\r\n    }))\r\n}\r\n\r\nmodule.exports = {\r\n    mBuild\r\n}\r\n","const qVariables = require('./mixins/doc/qVariables.js')\r\nconst qSelections = require('./mixins/doc/qSelections.js')\r\nconst qTablesAndFields = require('./mixins/doc/qTablesAndFields.js')\r\nconst extensionObjects = require('./mixins/doc/extension-objects.js')\r\n// const unbuildVariables = require('./mixins/doc/unbuild/variables.js')\r\n// const unbuildScript = require('./mixins/doc/unbuild/script.js')\r\n// const unbuildAppProperties = require('./mixins/doc/unbuild/appProperties.js')\r\n// const unbuildConnections = require('./mixins/doc/unbuild/connections.js')\r\n// const unbuildEntities = require('./mixins/doc/unbuild/entities.js')\r\nconst unbuild = require('./mixins/doc/unbuild.js')\r\nconst build = require('./mixins/doc/build.js')\r\n\r\nconst docMixin = [\r\n    {\r\n        types: ['Doc'],\r\n        init(args) {\r\n\r\n        },\r\n        extend: {\r\n            ...qSelections,\r\n            ...qTablesAndFields,\r\n            ...qVariables,\r\n            ...extensionObjects,\r\n            // ...unbuildVariables,\r\n            // ...unbuildScript,\r\n            // ...unbuildAppProperties,\r\n            // ...unbuildConnections,\r\n            // ...unbuildEntities,\r\n            ...unbuild,\r\n            ...build\r\n        },\r\n    }\r\n]\r\n\r\nmodule.exports = docMixin"],"names":["sessionList","variableList","listBox","mGetVariablesAll","async","showSession","showConfig","showReserved","objProp","objectDefinitions","qShowSession","qShowConfig","qShowReserved","sessionObj","this","createSessionObject","getLayout","qVariableList","qItems","e","Error","message","mUpdateVariable","variable","variableContent","getVariableById","qInfo","qId","setProperties","mCreateVariable","name","comment","definition","varProps","createVariableEx","iGetSelectionsNative","qDoc","mGetSelectionsCurr","selections","fieldsSelected","qSelectionObject","qSelections","map","s","qField","fields","mGetSelectionsCurrNative","mSelectInField","fieldName","values","toggle","field","getField","valuesToSelect","v","qText","selectValues","qFieldValues","qToggleMode","mGetTablesAndFields","tables","getTablesAndKeys","f","qtr","length","table","qFields","push","qName","mGetTables","qTables","mGetFields","mGetListbox","lbDef","qListObjectDef","qDef","qFieldDefs","qListObject","nonExtensionObjects","realExtensionCheck","objId","isExtension","qObjProps","qObj","getObject","getProperties","extensionMeta","mGetAllExtensionObjects","allInfos","getAllInfos","allObjects","possibleExtensionObjects","filter","o","indexOf","qType","realExtensionObjects","extObj","isReallyExtension","appName","id","objType","extName","extVersion","version","extVisible","visible","extIsBundle","isThirdParty","extIsLibrary","isLibraryItem","qProps","filterOnlyExtensionObjects","handlePromise","promise","then","data","undefined","catch","error","Promise","resolve","require$$0","unbuildVariables","app","sessionObjErr","sessionObjLayout","sessionObjLayoutErr","delSessionObj","delSessionObjErr","destroySessionObject","unbuildScript","script","scriptErr","getScript","unbuildAppProperties","appProperties","appPropertiesError","getAppProperties","unbuildConnections","appConnections","appConnectionsErr","getConnections","unbuildEntities","dimensions","measures","objects","appAllInfos","appAllInfosErr","all","item","dim","dimErr","getDimension","dimProp","dimPropErr","measure","measureErr","getMeasure","measureProp","measurePropErr","obj","objErr","parent","parentErr","getParent","children","childrenErr","getChildInfos","propTree","propTreeErr","getFullPropertyTree","prop","propErr","processObject","mUnbuild","variables","connections","processMeasures","created","createMeasure","status","updated","processDimensions","dimension","createDimension","processScript","setScript","processAppProperties","update","setAppProperties","processVariables","qVar","qVarError","getVariableByName","processConnections","connection","conn","find","create","createConnection","modify","modifyConnection","processObjects","object","isGenericObject","qProperty","objError","setFullPropertyTree","oError","createObject","updatedError","createdError","types","init","args","extend","qTablesAndFields","qVariables","extensionObjects","unbuild","mBuild","d"],"mappings":"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"}